<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Untitled 1</title>
</head>

<body>

<h1>Introduction</h1>
<p>eMote .NOWs come with radio networking capabilities built in. This app note 
shows you how to use the radio to communicate between two motes. In this app 
note, the motes converge to a common number that is incremented alternately by 
each mote after it receives a message from the other. In case one mote goes down 
or goes out of range, they will reconverge when both are available again.</p>
<h1>Setup</h1>
<p>You'll need two eMote .NOWs for this app note. Check the How-To *** article 
for tips on deploying and debugging when you have more than one mote. Otherwise, 
the setup is the same as for the Scrolling Hello World *** app note.</p>
<h1>Discussion</h1>
<p>The basic idea behind this app note is pretty simple. Both motes are running 
the same program. When one starts, it chooses a number at random as its current 
value and sends it to the other via the radio. When a mote gets a message from 
the other, it uses the maximum of the current &amp; received value, adds 1, and 
sends the new value back. This way, both converge on the same value and take 
turns incrementing it. Now we get into some of the details.</p>
<p>First, the radio. There are a variety of ways to use a radio to communicate 
between motes; these are called "protocols". The most common protocol is CSMA, 
which stands for Carrier Sense Multiple Access. The protocol tries to avoid 
situations where two devices are trying to transmit at the same time. When this 
collision happens, nothing gets through. It's rather like two people trying to 
talk at the same time: you'll have a hard time understanding either one. So CSMA 
listens before sending and only sends when the channel is clear. Of course, 
collisions can still happen, as is the case when two people, trying to be 
polite, nevertheless start talking at the same moment. In that case, the devices 
will back off randomly and try again later. See
<a href="http://www.youtube.com/watch?v=oCYWpDTD8Dc">
http://www.youtube.com/watch?v=oCYWpDTD8Dc</a> for a short video about this or
<a href="http://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_avoidance">
http://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_avoidance</a> 
for a longer description.</p>
<p>This app note includes the C# code for a class, SimpleCsmaRadio, that takes 
care of a lot of the setup. In the main program, we create a SimpleCsmaRadio 
instance. The first argument of the constructor is amount of time to listen (in 
ms) to check if no one else is sending before trying to send. The second 
argument is the power level for the radio. Lower power levels use less power 
(and hence increase the lifetime if running on batteries) but give a shorter 
communication range; and vice versa for higher power levels. The third argument 
gives a method that we provide; it will be called whenever a message is 
received. Once the instance is created, the radio is active.</p>
<p>The RadioReceive method takes a CSMA object as its argument. That object 
contains a variety of information, including the packet that contains the actual 
information sent (the "payload"). The method makes sure that there actually is a 
packet, that there's something in the packet, and that the payload is for us. 
Each message sent by this program has a header, the string "PingPong", as the 
first part of the payload, so if that's not present, we ignore it. Finally, it 
checks that the rest of the packet is an integer. If so, that's the value that 
was sent by the other node. In that case, the following happens:</p>
<ol>
	<li>We compare the received value with our current value and choose the 
	greater. That's how we converge to the same value.</li>
	<li>We increment the value by one and display it. This lets us confirm that 
	the program is actually running.</li>
	<li>We start a timer. Upon the completion of the timer, our current value is 
	sent out. This delay keeps the update process slow enough that we can watch 
	it happen on the display.</li>
</ol>
<p>Note the use of a timer to delay sending the message. It would be tempting to 
use a Thread.Sleep in the RadioReceive method. However, this method is called as 
part of an message-received interrupt call-back, which should complete as 
quickly as possible. So rather than delay it by sleeping in the method, a timer, 
which runs in a separate thread, assumes responsibility for the transmission and 
the RadioReceive method can exit without further delay.</p>
<p>Note that in what we've described so far, a mote will send it's value out 
once and then wait for the other to receive it and respond. What happens if the 
other mote is not available? In that case, when the mote has decided that the 
other mote is not responding, it will send out another message, and continue to 
do so periodically until it hears back. Thus you can start one mote and after a 
while, start the other one, and they will get in step with each other. So a 
second timer, with a longer interval, is used in case the other mote is 
unresponsive. When it fires, the current value is resent and the timer is 
restarted. That timer gets reset whenever the mote hears from the other, so in 
the normal case when the motes are communicating, it will never fire. But if 
either mote becomes unresponsive, it will fire periodically until it again hears 
from the other mote.</p>
<h1>Extensions</h1>
<p>Try incorporating a switch (see On-Off Switch ***). When the switch is 
pressed, choose a new random number. Watch the motes re-converge to the correct 
value.</p>
<p>Designate one of the motes as a base station and send the current value to a 
PC. See Serial On-Off Switch *** for an example of how to communicate with the 
PC.</p>

</body>

</html>
